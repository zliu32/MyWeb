{"remainingRequest":"C:\\Users\\Frank Liu\\Documents\\Github\\MyWeb\\myapp\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--8-1!C:\\Users\\Frank Liu\\Documents\\Github\\MyWeb\\myapp\\node_modules\\@swimlane\\ngx-charts\\release\\area-chart\\area-series.component.js","dependencies":[{"path":"C:\\Users\\Frank Liu\\Documents\\Github\\MyWeb\\myapp\\node_modules\\@swimlane\\ngx-charts\\release\\area-chart\\area-series.component.js","mtime":499162500000},{"path":"C:\\Users\\Frank Liu\\Documents\\Github\\MyWeb\\myapp\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1529671348740},{"path":"C:\\Users\\Frank Liu\\Documents\\Github\\MyWeb\\myapp\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1528256844000}],"contextDependencies":[],"result":["import { __decorate } from \"tslib\";\nimport { __metadata } from \"tslib\";\nimport { Component, Input, Output, EventEmitter, ChangeDetectionStrategy } from '@angular/core';\nimport { area } from 'd3-shape';\nimport { sortLinear, sortByTime, sortByDomain } from '../utils/sort';\nvar AreaSeriesComponent = /** @class */ /*@__PURE__*/ (function () {\n    function AreaSeriesComponent() {\n        this.baseValue = 'auto';\n        this.stacked = false;\n        this.normalized = false;\n        this.animations = true;\n        this.select = new EventEmitter();\n    }\n    AreaSeriesComponent.prototype.ngOnChanges = function (changes) {\n        this.update();\n    };\n    AreaSeriesComponent.prototype.update = function () {\n        var _this = this;\n        this.updateGradient();\n        var currentArea;\n        var startingArea;\n        var xProperty = function (d) {\n            var label = d.name;\n            return _this.xScale(label);\n        };\n        if (this.stacked || this.normalized) {\n            currentArea = area()\n                .x(xProperty)\n                .y0(function (d, i) { return _this.yScale(d.d0); })\n                .y1(function (d, i) { return _this.yScale(d.d1); });\n            startingArea = area()\n                .x(xProperty)\n                .y0(function (d) { return _this.yScale.range()[0]; })\n                .y1(function (d) { return _this.yScale.range()[0]; });\n        }\n        else {\n            currentArea = area()\n                .x(xProperty)\n                .y0(function () { return _this.baseValue === 'auto' ? _this.yScale.range()[0] : _this.yScale(_this.baseValue); })\n                .y1(function (d) { return _this.yScale(d.value); });\n            startingArea = area()\n                .x(xProperty)\n                .y0(function (d) { return _this.baseValue === 'auto' ? _this.yScale.range()[0] : _this.yScale(_this.baseValue); })\n                .y1(function (d) { return _this.baseValue === 'auto' ? _this.yScale.range()[0] : _this.yScale(_this.baseValue); });\n        }\n        currentArea.curve(this.curve);\n        startingArea.curve(this.curve);\n        this.opacity = .8;\n        var data = this.data.series;\n        if (this.scaleType === 'linear') {\n            data = sortLinear(data, 'name');\n        }\n        else if (this.scaleType === 'time') {\n            data = sortByTime(data, 'name');\n        }\n        else {\n            data = sortByDomain(data, 'name', 'asc', this.xScale.domain());\n        }\n        this.path = currentArea(data);\n        this.startingPath = startingArea(data);\n    };\n    AreaSeriesComponent.prototype.updateGradient = function () {\n        if (this.colors.scaleType === 'linear') {\n            this.hasGradient = true;\n            if (this.stacked || this.normalized) {\n                var d0values = this.data.series.map(function (d) { return d.d0; });\n                var d1values = this.data.series.map(function (d) { return d.d1; });\n                var max = Math.max.apply(Math, d1values);\n                var min = Math.min.apply(Math, d0values);\n                this.gradientStops = this.colors.getLinearGradientStops(max, min);\n            }\n            else {\n                var values = this.data.series.map(function (d) { return d.value; });\n                var max = Math.max.apply(Math, values);\n                this.gradientStops = this.colors.getLinearGradientStops(max);\n            }\n        }\n        else {\n            this.hasGradient = false;\n            this.gradientStops = undefined;\n        }\n    };\n    AreaSeriesComponent.prototype.isActive = function (entry) {\n        if (!this.activeEntries)\n            return false;\n        var item = this.activeEntries.find(function (d) {\n            return entry.name === d.name;\n        });\n        return item !== undefined;\n    };\n    AreaSeriesComponent.prototype.isInactive = function (entry) {\n        if (!this.activeEntries || this.activeEntries.length === 0)\n            return false;\n        var item = this.activeEntries.find(function (d) {\n            return entry.name === d.name;\n        });\n        return item === undefined;\n    };\n    return AreaSeriesComponent;\n}());\nexport { AreaSeriesComponent };\n//# sourceMappingURL=area-series.component.js.map\n",null]}