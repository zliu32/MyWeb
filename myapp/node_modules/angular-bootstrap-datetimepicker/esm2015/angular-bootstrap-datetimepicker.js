/**
 * Copyright (c) 2013-present Dale Lotts
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

import * as _moment from 'moment';
import { Inject, InjectionToken, ChangeDetectionStrategy, Component, ElementRef, EventEmitter, Input, NgZone, Output, NgModule } from '@angular/core';
import { NG_VALUE_ACCESSOR } from '@angular/forms';
import { take } from 'rxjs/operators';
import { CommonModule } from '@angular/common';

class DlDateAdapter {
}

const moment = _moment;
class DlDateAdapterMoment extends DlDateAdapter {
    fromMilliseconds(milliseconds) {
        return moment(milliseconds);
    }
    toMilliseconds(value) {
        return (value) ? value.valueOf() : undefined;
    }
}

class DlDateAdapterNative extends DlDateAdapter {
    fromMilliseconds(milliseconds) {
        return new Date(milliseconds);
    }
    toMilliseconds(value) {
        return (value) ? value.getTime() : undefined;
    }
}

class DlDateAdapterNumber extends DlDateAdapter {
    fromMilliseconds(milliseconds) {
        return milliseconds;
    }
    toMilliseconds(value) {
        return value;
    }
}

const moment$1 = _moment;
const DL_STRING_DATE_OUTPUT_FORMAT = new InjectionToken('DL_STRING_DATE_OUTPUT_FORMAT');
const DL_STRING_DATE_INPUT_FORMATS = new InjectionToken('DL_STRING_DATE_INPUT_FORMATS');
class DlDateAdapterString extends DlDateAdapter {
    constructor(inputFormats, modelFormat) {
        super();
        this.inputFormats = inputFormats;
        this.modelFormat = modelFormat;
    }
    fromMilliseconds(milliseconds) {
        return moment$1(milliseconds).format(this.modelFormat);
    }
    toMilliseconds(value) {
        if (value !== undefined && value !== null) {
            const                  newMoment = moment$1(value, this.inputFormats, true);
            return newMoment.isValid() ? newMoment.valueOf() : undefined;
        }
    }
}
DlDateAdapterString.ctorParameters = () => [
    { type: Array, decorators: [{ type: Inject, args: [DL_STRING_DATE_INPUT_FORMATS,] },] },
    { type: undefined, decorators: [{ type: Inject, args: [DL_STRING_DATE_OUTPUT_FORMAT,] },] },
];

class DlDateTimePickerChange {
    constructor(newValue) {
        this._value = newValue;
    }
    get value() {
        return this._value;
    }
}

const moment$2 = _moment;
class DlYearModelProvider {
    static getStartOfDecade(fromMilliseconds) {
        const                  startDecade = (Math.trunc(moment$2(fromMilliseconds).year() / 10) * 10);
        return moment$2({ year: startDecade }).startOf('year');
    }
    onChanges(changes) {
    }
    getModel(milliseconds, selectedMilliseconds) {
        const                  rowNumbers = [0, 1];
        const                  columnNumbers = [0, 1, 2, 3, 4];
        const                  startYear = moment$2(milliseconds).startOf('year');
        const                  startDate = DlYearModelProvider.getStartOfDecade(milliseconds);
        const                  futureYear = startDate.year() + 9;
        const                  pastYear = startDate.year();
        const                  activeValue = startYear.valueOf();
        const                  selectedValue = selectedMilliseconds === null || selectedMilliseconds === undefined
            ? selectedMilliseconds
            : moment$2(selectedMilliseconds).startOf('year').valueOf();
        const                  result = {
            viewName: 'year',
            viewLabel: `${pastYear}-${futureYear}`,
            activeDate: activeValue,
            leftButton: {
                value: moment$2(startDate).subtract(10, 'years').valueOf(),
                ariaLabel: `Go to ${pastYear - 10}-${pastYear - 1}`,
                classes: {},
            },
            rightButton: {
                value: moment$2(startDate).add(10, 'years').valueOf(),
                ariaLabel: `Go to ${futureYear + 1}-${futureYear + 10}`,
                classes: {},
            },
            rows: rowNumbers.map(rowOfYears.bind(this))
        };
        result.leftButton.classes[`${result.leftButton.value}`] = true;
        result.rightButton.classes[`${result.rightButton.value}`] = true;
        return result;
        function rowOfYears(rowNumber) {
            const                  currentMoment = moment$2();
            const                  cells = columnNumbers.map((columnNumber) => {
                const                  yearMoment = moment$2(startDate).add((rowNumber * columnNumbers.length) + columnNumber, 'years');
                return {
                    display: yearMoment.format('YYYY'),
                    value: yearMoment.valueOf(),
                    classes: {
                        'dl-abdtp-active': activeValue === yearMoment.valueOf(),
                        'dl-abdtp-selected': selectedValue === yearMoment.valueOf(),
                        'dl-abdtp-now': yearMoment.isSame(currentMoment, 'year'),
                    }
                };
            });
            return { cells };
        }
    }
    goDown(fromMilliseconds, selectedMilliseconds) {
        return this.getModel(moment$2(fromMilliseconds).add(5, 'year').valueOf(), selectedMilliseconds);
    }
    goUp(fromMilliseconds, selectedMilliseconds) {
        return this.getModel(moment$2(fromMilliseconds).subtract(5, 'year').valueOf(), selectedMilliseconds);
    }
    goLeft(fromMilliseconds, selectedMilliseconds) {
        return this.getModel(moment$2(fromMilliseconds).subtract(1, 'year').valueOf(), selectedMilliseconds);
    }
    goRight(fromMilliseconds, selectedMilliseconds) {
        return this.getModel(moment$2(fromMilliseconds).add(1, 'year').valueOf(), selectedMilliseconds);
    }
    pageDown(fromMilliseconds, selectedMilliseconds) {
        return this.getModel(moment$2(fromMilliseconds).add(10, 'year').valueOf(), selectedMilliseconds);
    }
    pageUp(fromMilliseconds, selectedMilliseconds) {
        return this.getModel(moment$2(fromMilliseconds).subtract(10, 'year').valueOf(), selectedMilliseconds);
    }
    goEnd(fromMilliseconds, selectedMilliseconds) {
        return this.getModel(DlYearModelProvider.getStartOfDecade(fromMilliseconds)
            .add(9, 'years')
            .endOf('year')
            .valueOf(), selectedMilliseconds);
    }
    goHome(fromMilliseconds, selectedMilliseconds) {
        return this.getModel(DlYearModelProvider.getStartOfDecade(fromMilliseconds)
            .startOf('year')
            .valueOf(), selectedMilliseconds);
    }
}

const moment$3 = _moment;
class DlMonthModelProvider {
    onChanges(changes) {
    }
    getModel(milliseconds, selectedMilliseconds) {
        const                  startDate = moment$3(milliseconds).startOf('year');
        const                  rowNumbers = [0, 1, 2];
        const                  columnNumbers = [0, 1, 2, 3];
        const                  previousYear = moment$3(startDate).subtract(1, 'year');
        const                  nextYear = moment$3(startDate).add(1, 'year');
        const                  activeValue = moment$3(milliseconds).startOf('month').valueOf();
        const                  selectedValue = selectedMilliseconds === null || selectedMilliseconds === undefined
            ? selectedMilliseconds
            : moment$3(selectedMilliseconds).startOf('month').valueOf();
        const                  result = {
            viewName: 'month',
            viewLabel: startDate.format('YYYY'),
            activeDate: activeValue,
            leftButton: {
                value: previousYear.valueOf(),
                ariaLabel: `Go to ${previousYear.format('YYYY')}`,
                classes: {},
            },
            upButton: {
                value: startDate.valueOf(),
                ariaLabel: `Go to ${startDate.format('YYYY')}`,
                classes: {},
            },
            rightButton: {
                value: nextYear.valueOf(),
                ariaLabel: `Go to ${nextYear.format('YYYY')}`,
                classes: {},
            },
            rows: rowNumbers.map(rowOfMonths)
        };
        result.leftButton.classes[`${result.leftButton.value}`] = true;
        result.rightButton.classes[`${result.rightButton.value}`] = true;
        return result;
        function rowOfMonths(rowNumber) {
            const                  currentMoment = moment$3();
            const                  cells = columnNumbers.map((columnNumber) => {
                const                  monthMoment = moment$3(startDate).add((rowNumber * columnNumbers.length) + columnNumber, 'months');
                return {
                    display: monthMoment.format('MMM'),
                    ariaLabel: monthMoment.format('MMM YYYY'),
                    value: monthMoment.valueOf(),
                    classes: {
                        'dl-abdtp-active': activeValue === monthMoment.valueOf(),
                        'dl-abdtp-selected': selectedValue === monthMoment.valueOf(),
                        'dl-abdtp-now': monthMoment.isSame(currentMoment, 'month'),
                    }
                };
            });
            return { cells };
        }
    }
    goDown(fromMilliseconds, selectedMilliseconds) {
        return this.getModel(moment$3(fromMilliseconds).add(4, 'month').valueOf(), selectedMilliseconds);
    }
    goUp(fromMilliseconds, selectedMilliseconds) {
        return this.getModel(moment$3(fromMilliseconds).subtract(4, 'month').valueOf(), selectedMilliseconds);
    }
    goLeft(fromMilliseconds, selectedMilliseconds) {
        return this.getModel(moment$3(fromMilliseconds).subtract(1, 'month').valueOf(), selectedMilliseconds);
    }
    goRight(fromMilliseconds, selectedMilliseconds) {
        return this.getModel(moment$3(fromMilliseconds).add(1, 'month').valueOf(), selectedMilliseconds);
    }
    pageDown(fromMilliseconds, selectedMilliseconds) {
        return this.getModel(moment$3(fromMilliseconds).add(12, 'months').valueOf(), selectedMilliseconds);
    }
    pageUp(fromMilliseconds, selectedMilliseconds) {
        return this.getModel(moment$3(fromMilliseconds).subtract(12, 'months').valueOf(), selectedMilliseconds);
    }
    goEnd(fromMilliseconds, selectedMilliseconds) {
        return this.getModel(moment$3(fromMilliseconds).endOf('year').valueOf(), selectedMilliseconds);
    }
    goHome(fromMilliseconds, selectedMilliseconds) {
        return this.getModel(moment$3(fromMilliseconds).startOf('year').valueOf(), selectedMilliseconds);
    }
}

const moment$4 = _moment;
class DlDayModelProvider {
    onChanges(changes) {
    }
    getModel(milliseconds, selectedMilliseconds) {
        const                  startOfMonth = moment$4(milliseconds).startOf('month');
        const                  endOfMonth = moment$4(milliseconds).endOf('month');
        const                  startOfView = moment$4(startOfMonth).subtract(Math.abs(startOfMonth.weekday()), 'days');
        const                  rowNumbers = [0, 1, 2, 3, 4, 5];
        const                  columnNumbers = [0, 1, 2, 3, 4, 5, 6];
        const                  previousMonth = moment$4(startOfMonth).subtract(1, 'month');
        const                  nextMonth = moment$4(startOfMonth).add(1, 'month');
        const                  activeValue = moment$4(milliseconds).startOf('day').valueOf();
        const                  selectedValue = selectedMilliseconds === null || selectedMilliseconds === undefined
            ? selectedMilliseconds
            : moment$4(selectedMilliseconds).startOf('day').valueOf();
        const                  result = {
            viewName: 'day',
            viewLabel: startOfMonth.format('MMM YYYY'),
            activeDate: activeValue,
            leftButton: {
                value: previousMonth.valueOf(),
                ariaLabel: `Go to ${previousMonth.format('MMM YYYY')}`,
                classes: {},
            },
            upButton: {
                value: startOfMonth.valueOf(),
                ariaLabel: `Go to month view`,
                classes: {},
            },
            rightButton: {
                value: nextMonth.valueOf(),
                ariaLabel: `Go to ${nextMonth.format('MMM YYYY')}`,
                classes: {},
            },
            rowLabels: columnNumbers.map((column) => moment$4().weekday(column).format('dd')),
            rows: rowNumbers.map(rowOfDays)
        };
        result.leftButton.classes[`${result.leftButton.value}`] = true;
        result.rightButton.classes[`${result.rightButton.value}`] = true;
        return result;
        function rowOfDays(rowNumber) {
            const                  currentMoment = moment$4();
            const                  cells = columnNumbers.map((columnNumber) => {
                const                  dayMoment = moment$4(startOfView).add((rowNumber * columnNumbers.length) + columnNumber, 'days');
                return {
                    display: dayMoment.format('D'),
                    ariaLabel: dayMoment.format('ll'),
                    value: dayMoment.valueOf(),
                    classes: {
                        'dl-abdtp-active': activeValue === dayMoment.valueOf(),
                        'dl-abdtp-future': dayMoment.isAfter(endOfMonth),
                        'dl-abdtp-past': dayMoment.isBefore(startOfMonth),
                        'dl-abdtp-selected': selectedValue === dayMoment.valueOf(),
                        'dl-abdtp-now': dayMoment.isSame(currentMoment, 'day'),
                    }
                };
            });
            return { cells };
        }
    }
    goDown(fromMilliseconds, selectedMilliseconds) {
        return this.getModel(moment$4(fromMilliseconds).add(7, 'days').valueOf(), selectedMilliseconds);
    }
    goUp(fromMilliseconds, selectedMilliseconds) {
        return this.getModel(moment$4(fromMilliseconds).subtract(7, 'days').valueOf(), selectedMilliseconds);
    }
    goLeft(fromMilliseconds, selectedMilliseconds) {
        return this.getModel(moment$4(fromMilliseconds).subtract(1, 'day').valueOf(), selectedMilliseconds);
    }
    goRight(fromMilliseconds, selectedMilliseconds) {
        return this.getModel(moment$4(fromMilliseconds).add(1, 'day').valueOf(), selectedMilliseconds);
    }
    pageDown(fromMilliseconds, selectedMilliseconds) {
        return this.getModel(moment$4(fromMilliseconds).add(1, 'month').valueOf(), selectedMilliseconds);
    }
    pageUp(fromMilliseconds, selectedMilliseconds) {
        return this.getModel(moment$4(fromMilliseconds).subtract(1, 'month').valueOf(), selectedMilliseconds);
    }
    goEnd(fromMilliseconds, selectedMilliseconds) {
        return this.getModel(moment$4(fromMilliseconds)
            .endOf('month').startOf('day').valueOf(), selectedMilliseconds);
    }
    goHome(fromMilliseconds, selectedMilliseconds) {
        return this.getModel(moment$4(fromMilliseconds).startOf('month').valueOf(), selectedMilliseconds);
    }
}

const moment$5 = _moment;
class DlHourModelProvider {
    onChanges(changes) {
    }
    getModel(milliseconds, selectedMilliseconds) {
        const                  startDate = moment$5(milliseconds).startOf('day');
        const                  rowNumbers = [0, 1, 2, 3, 4, 5];
        const                  columnNumbers = [0, 1, 2, 3];
        const                  previousDay = moment$5(startDate).subtract(1, 'day');
        const                  nextDay = moment$5(startDate).add(1, 'day');
        const                  activeValue = moment$5(milliseconds).startOf('hour').valueOf();
        const                  selectedValue = selectedMilliseconds === null || selectedMilliseconds === undefined
            ? selectedMilliseconds
            : moment$5(selectedMilliseconds).startOf('hour').valueOf();
        const                  result = {
            viewName: 'hour',
            viewLabel: startDate.format('ll'),
            activeDate: activeValue,
            leftButton: {
                value: previousDay.valueOf(),
                ariaLabel: `Go to ${previousDay.format('ll')}`,
                classes: {},
            },
            upButton: {
                value: startDate.valueOf(),
                ariaLabel: `Go to ${startDate.format('MMM YYYY')}`,
                classes: {},
            },
            rightButton: {
                value: nextDay.valueOf(),
                ariaLabel: `Go to ${nextDay.format('ll')}`,
                classes: {},
            },
            rows: rowNumbers.map(rowOfHours)
        };
        result.leftButton.classes[`${result.leftButton.value}`] = true;
        result.rightButton.classes[`${result.rightButton.value}`] = true;
        return result;
        function rowOfHours(rowNumber) {
            const                  currentMoment = moment$5();
            const                  cells = columnNumbers.map((columnNumber) => {
                const                  hourMoment = moment$5(startDate).add((rowNumber * columnNumbers.length) + columnNumber, 'hours');
                return {
                    display: hourMoment.format('LT'),
                    ariaLabel: hourMoment.format('LLL'),
                    value: hourMoment.valueOf(),
                    classes: {
                        'dl-abdtp-active': activeValue === hourMoment.valueOf(),
                        'dl-abdtp-selected': selectedValue === hourMoment.valueOf(),
                        'dl-abdtp-now': hourMoment.isSame(currentMoment, 'hour'),
                    }
                };
            });
            return { cells };
        }
    }
    goDown(fromMilliseconds, selectedMilliseconds) {
        return this.getModel(moment$5(fromMilliseconds).add(4, 'hour').valueOf(), selectedMilliseconds);
    }
    goUp(fromMilliseconds, selectedMilliseconds) {
        return this.getModel(moment$5(fromMilliseconds).subtract(4, 'hour').valueOf(), selectedMilliseconds);
    }
    goLeft(fromMilliseconds, selectedMilliseconds) {
        return this.getModel(moment$5(fromMilliseconds).subtract(1, 'hour').valueOf(), selectedMilliseconds);
    }
    goRight(fromMilliseconds, selectedMilliseconds) {
        return this.getModel(moment$5(fromMilliseconds).add(1, 'hour').valueOf(), selectedMilliseconds);
    }
    pageDown(fromMilliseconds, selectedMilliseconds) {
        return this.getModel(moment$5(fromMilliseconds).add(1, 'day').valueOf(), selectedMilliseconds);
    }
    pageUp(fromMilliseconds, selectedMilliseconds) {
        return this.getModel(moment$5(fromMilliseconds).subtract(1, 'day').valueOf(), selectedMilliseconds);
    }
    goEnd(fromMilliseconds, selectedMilliseconds) {
        return this.getModel(moment$5(fromMilliseconds)
            .endOf('day')
            .startOf('hour')
            .valueOf(), selectedMilliseconds);
    }
    goHome(fromMilliseconds, selectedMilliseconds) {
        return this.getModel(moment$5(fromMilliseconds).startOf('day').valueOf(), selectedMilliseconds);
    }
}

const moment$6 = _moment;
class DlMinuteModelProvider {
    constructor() {
        this.step = 5;
    }
    onChanges(changes) {
        const                  minuteStepChange = changes['minuteStep'];
        if (minuteStepChange
            && (minuteStepChange.previousValue !== minuteStepChange.currentValue)) {
            this.step = minuteStepChange.currentValue;
            if (this.step === null || this.step === undefined) {
                this.step = 5;
            }
        }
    }
    getModel(milliseconds, selectedMilliseconds) {
        const                  startDate = moment$6(milliseconds).startOf('hour');
        const                  currentMilliseconds = moment$6().valueOf();
        const                  minuteSteps = new Array(Math.ceil(60 / this.step)).fill(0).map((value, index) => index * this.step);
        const                  minuteValues = minuteSteps.map((minutesToAdd) => moment$6(startDate).add(minutesToAdd, 'minutes').valueOf());
        const                  activeValue = moment$6(minuteValues.filter((value) => value <= milliseconds).pop()).valueOf();
        const                  nowValue = currentMilliseconds >= startDate.valueOf() && currentMilliseconds <= moment$6(startDate).endOf('hour').valueOf()
            ? moment$6(minuteValues.filter((value) => value <= currentMilliseconds).pop()).valueOf()
            : null;
        const                  previousHour = moment$6(startDate).subtract(1, 'hour');
        const                  nextHour = moment$6(startDate).add(1, 'hour');
        const                  selectedValue = selectedMilliseconds === null || selectedMilliseconds === undefined
            ? selectedMilliseconds
            : moment$6(minuteValues.filter((value) => value <= selectedMilliseconds).pop()).valueOf();
        const                  rows = new Array(Math.ceil(minuteSteps.length / 4))
            .fill(0)
            .map((value, index) => index)
            .map((value) => {
            return { cells: minuteSteps.slice((value * 4), (value * 4) + 4).map(rowOfMinutes) };
        });
        const                  result = {
            viewName: 'minute',
            viewLabel: startDate.format('lll'),
            activeDate: activeValue,
            leftButton: {
                value: previousHour.valueOf(),
                ariaLabel: `Go to ${previousHour.format('lll')}`,
                classes: {},
            },
            upButton: {
                value: startDate.valueOf(),
                ariaLabel: `Go to ${startDate.format('ll')}`,
                classes: {},
            },
            rightButton: {
                value: nextHour.valueOf(),
                ariaLabel: `Go to ${nextHour.format('lll')}`,
                classes: {},
            },
            rows
        };
        result.leftButton.classes[`${result.leftButton.value}`] = true;
        result.rightButton.classes[`${result.rightButton.value}`] = true;
        return result;
        function rowOfMinutes(stepMinutes) {
            const                  minuteMoment = moment$6(startDate).add(stepMinutes, 'minutes');
            return {
                display: minuteMoment.format('LT'),
                ariaLabel: minuteMoment.format('LLL'),
                value: minuteMoment.valueOf(),
                classes: {
                    'dl-abdtp-active': activeValue === minuteMoment.valueOf(),
                    'dl-abdtp-selected': selectedValue === minuteMoment.valueOf(),
                    'dl-abdtp-now': nowValue === minuteMoment.valueOf(),
                }
            };
        }
    }
    goDown(fromMilliseconds, selectedMilliseconds) {
        return this.getModel(moment$6(fromMilliseconds).add(this.step * 4, 'minutes').valueOf(), selectedMilliseconds);
    }
    goUp(fromMilliseconds, selectedMilliseconds) {
        return this.getModel(moment$6(fromMilliseconds).subtract(this.step * 4, 'minutes').valueOf(), selectedMilliseconds);
    }
    goLeft(fromMilliseconds, selectedMilliseconds) {
        return this.getModel(moment$6(fromMilliseconds).subtract(this.step, 'minutes').valueOf(), selectedMilliseconds);
    }
    goRight(fromMilliseconds, selectedMilliseconds) {
        return this.getModel(moment$6(fromMilliseconds).add(this.step, 'minutes').valueOf(), selectedMilliseconds);
    }
    pageDown(fromMilliseconds, selectedMilliseconds) {
        return this.getModel(moment$6(fromMilliseconds).add(1, 'hour').valueOf(), selectedMilliseconds);
    }
    pageUp(fromMilliseconds, selectedMilliseconds) {
        return this.getModel(moment$6(fromMilliseconds).subtract(1, 'hour').valueOf(), selectedMilliseconds);
    }
    goEnd(fromMilliseconds, selectedMilliseconds) {
        return this.getModel(moment$6(fromMilliseconds)
            .endOf('hour')
            .valueOf(), selectedMilliseconds);
    }
    goHome(fromMilliseconds, selectedMilliseconds) {
        return this.getModel(moment$6(fromMilliseconds).startOf('hour').valueOf(), selectedMilliseconds);
    }
}

const moment$7 = _moment;
const keyCodeToModelProviderMethod = {
    33: 'pageUp',
    34: 'pageDown',
    35: 'goEnd',
    36: 'goHome',
    37: 'goLeft',
    38: 'goUp',
    39: 'goRight',
    40: 'goDown',
};
const VIEWS = [
    'minute',
    'hour',
    'day',
    'month',
    'year'
];
class DlDateTimePickerComponent {
    constructor(_elementRef, _ngZone, _dateAdapter, yearModelComponent, monthModelComponent, dayModelComponent, hourModelComponent, minuteModelComponent) {
        this._elementRef = _elementRef;
        this._ngZone = _ngZone;
        this._dateAdapter = _dateAdapter;
        this.yearModelComponent = yearModelComponent;
        this.monthModelComponent = monthModelComponent;
        this.dayModelComponent = dayModelComponent;
        this.hourModelComponent = hourModelComponent;
        this.minuteModelComponent = minuteModelComponent;
        this.leftIconClass = [
            'oi',
            'oi-chevron-left'
        ];
        this.maxView = 'year';
        this.minuteStep = 5;
        this.minView = 'minute';
        this.rightIconClass = [
            'oi',
            'oi-chevron-right'
        ];
        this.startView = 'day';
        this.upIconClass = [
            'oi',
            'oi-chevron-top'
        ];
        this.change = new EventEmitter();
        this._changed = [];
        this._nextView = {
            'year': 'month',
            'month': 'day',
            'day': 'hour',
            'hour': 'minute'
        };
        this._previousView = {
            'minute': 'hour',
            'hour': 'day',
            'day': 'month',
            'month': 'year'
        };
        this._touched = [];
        this.selectFilter = () => true;
        this._viewToModelProvider = {
            year: yearModelComponent,
            month: monthModelComponent,
            day: dayModelComponent,
            hour: hourModelComponent,
            minute: minuteModelComponent,
        };
    }
    ngOnChanges(changes) {
        Object.keys(this._viewToModelProvider)
            .map((key) => this._viewToModelProvider[key])
            .forEach((provider) => provider.onChanges(changes));
        if (this._model) {
            this.model = this._viewToModelProvider[this._model.viewName].getModel(this._model.activeDate, this.valueOf);
        }
    }
    ngOnInit() {
        this.model = this._viewToModelProvider[this.getStartView()].getModel(this.getStartDate(), this.valueOf);
    }
    _onDateClick(dateButton) {
        if (dateButton.classes['dl-abdtp-disabled']) {
            return;
        }
        let                  nextView = this._nextView[this._model.viewName];
        if ((this.minView || 'minute') === this._model.viewName) {
            this.value = this._dateAdapter.fromMilliseconds(dateButton.value);
            nextView = this.startView;
        }
        this.model = this._viewToModelProvider[nextView].getModel(dateButton.value, this.valueOf);
        this.onTouch();
    }
    _onLeftClick() {
        this.model = this._viewToModelProvider[this._model.viewName].getModel(this._model.leftButton.value, this.valueOf);
        this.onTouch();
    }
    _onUpClick() {
        this.model = this._viewToModelProvider[this._previousView[this._model.viewName]].getModel(this._model.upButton.value, this.valueOf);
    }
    _onRightClick() {
        this.model = this._viewToModelProvider[this._model.viewName].getModel(this._model.rightButton.value, this.valueOf);
        this.onTouch();
    }
    _handleKeyDown($event) {
        const                  functionName = keyCodeToModelProviderMethod[$event.keyCode];
        if (functionName) {
            const                  modelProvider = this._viewToModelProvider[this._model.viewName];
            this.model = modelProvider[functionName](this._model.activeDate, this.valueOf);
            this.focusActiveCell();
            $event.preventDefault();
        }
    }
    applySelectFilter(model) {
        if (this.selectFilter) {
            model.rows = model.rows.map((row) => {
                row.cells.map((dateButton) => {
                    const                  disabled = !this.selectFilter(dateButton, model.viewName);
                    dateButton.classes['dl-abdtp-disabled'] = disabled;
                    if (disabled) {
                        dateButton.classes['aria-disabled'] = true;
                    }
                    return dateButton;
                });
                return row;
            });
        }
        return model;
    }
    focusActiveCell() {
        this._ngZone.runOutsideAngular(() => {
            this._ngZone.onStable.asObservable().pipe(take(1)).subscribe(() => {
                this._elementRef.nativeElement.querySelector('.dl-abdtp-active').focus();
            });
        });
    }
    getStartDate() {
        if (hasValue(this._value)) {
            return this._dateAdapter.toMilliseconds(this._value);
        }
        if (hasValue(this.startDate)) {
            return this.startDate;
        }
        return moment$7().valueOf();
    }
    getStartView() {
        const                  startIndex = Math.max(VIEWS.indexOf(this.minView || 'minute'), VIEWS.indexOf(this.startView || 'day'));
        return VIEWS[startIndex];
    }
    set model(model) {
        this._model = this.applySelectFilter(model);
    }
    onTouch() {
        this._touched.forEach((onTouch) => onTouch());
    }
    registerOnChange(fn) {
        this._changed.push(fn);
    }
    registerOnTouched(fn) {
        this._touched.push(fn);
    }
    get value() {
        return this._value;
    }
    set value(value) {
        if (this._value !== value) {
            this._value = value;
            this.model = this._viewToModelProvider[this._model.viewName].getModel(this.getStartDate(), this.valueOf);
            this._changed.forEach(f => f(value));
            this.change.emit(new DlDateTimePickerChange(value));
        }
    }
    get valueOf() {
        return this._dateAdapter.toMilliseconds(this._value);
    }
    writeValue(value) {
        this.value = value;
    }
}
DlDateTimePickerComponent.decorators = [
    { type: Component, args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false,
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: DlDateTimePickerComponent,
                        multi: true
                    }
                ],
                selector: 'dl-date-time-picker',
                styles: [`:host{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.dl-abdtp-col-label,.dl-abdtp-view-label{font-weight:700}.dl-abdtp-date-button,.dl-abdtp-left-button,.dl-abdtp-right-button,.dl-abdtp-view-label{padding:5px;border-radius:999px;cursor:pointer;color:rgba(0,0,0,.87);outline:0}.dl-abdtp-date-button,.dl-abdtp-left-button,.dl-abdtp-right-button,.dl-abdtp-up-button{border-width:0}.dl-abdtp-active:focus,.dl-abdtp-date-button:focus,.dl-abdtp-date-button:hover,.dl-abdtp-left-button:focus,.dl-abdtp-left-button:hover,.dl-abdtp-right-button:focus,.dl-abdtp-right-button:hover,.dl-abdtp-up-button:focus,.dl-abdtp-up-button:hover,.dl-abdtp-view-label:focus{background:rgba(0,0,0,.04)}.dl-abdtp-future,.dl-abdtp-past{color:rgba(0,0,0,.04)}.dl-abdtp-now,.dl-abdtp-now.disabled,.dl-abdtp-now.disabled:hover,.dl-abdtp-now:hover{border-radius:999px;border:1px solid rgba(0,0,0,.25)}.dl-abdtp-selected{color:#fff;background:rgba(0,82,204,.75)}.dl-abdtp-selected:focus,.dl-abdtp-selected:hover{background:#0052cc}.dl-abdtp-disabled{cursor:default;color:rgba(0,0,0,.25)}`],
                template: `<div class="text-center dl-abdtp-{{_model.viewName}}-view ">
  <div class="row align-items-center no-gutters">
    <button class="col dl-abdtp-left-button align-items-center"
            type="button"
            [attr.aria-label]="_model.leftButton.ariaLabel"
            [attr.title]="_model.leftButton.ariaLabel"
            [ngClass]="_model.leftButton.classes"
            (click)="_onLeftClick()">
      <span class="left-icon" [ngClass]="leftIconClass"></span>
    </button>
    <div *ngIf="_model.viewName === (this.maxView || 'year'); then maxViewLabel else defaultViewLabel;"></div>
    <button class="col dl-abdtp-right-button"
            type="button"
            [attr.aria-label]="_model.rightButton.ariaLabel"
            [attr.title]="_model.rightButton.ariaLabel"
            (click)="_onRightClick()"
            [ngClass]="_model.rightButton.classes">
      <span class="right-icon" [ngClass]="rightIconClass"></span>
    </button>
  </div>
  <div (keydown)="_handleKeyDown($event)">
    <div *ngIf="_model.rowLabels?.length" class="row no-gutters">
      <div *ngFor="let label of _model.rowLabels" class="col align-items-center no-gutters dl-abdtp-col-label">{{label}}</div>
    </div>
    <div *ngFor="let row of _model.rows" class="row align-items-center no-gutters">
      <div *ngFor="let cell of row.cells"
           role="gridcell"
           class="col dl-abdtp-date-button dl-abdtp-{{_model.viewName}} {{cell.value}}"
           [ngClass]="cell.classes"
           [attr.aria-label]="cell.ariaLabel"
           [attr.aria-disabled]="cell.classes['dl-abdtp-disabled']"
           [attr.tabindex]="cell.classes['dl-abdtp-active'] ? 0 : -1"
           (click)="_onDateClick(cell)"
           (keydown.space)="_onDateClick(cell)"
           (keydown.enter)="_onDateClick(cell)"
      >{{cell.display}}</div>
    </div>
  </div>
</div>
<ng-template #maxViewLabel>
  <div class="col-10 dl-abdtp-view-label">{{_model.viewLabel}}</div>
</ng-template>
<ng-template #defaultViewLabel>
  <button class="col-10 dl-abdtp-view-label dl-abdtp-up-button"
          type="button"
          [attr.aria-label]="_model.upButton.ariaLabel"
          [attr.title]="_model.upButton.ariaLabel"
          (click)="_onUpClick()"
          [ngClass]="_model.upButton.classes"
  >{{_model.viewLabel}}&nbsp;<span class="up-icon" [ngClass]="upIconClass"></span>
  </button>
</ng-template>
`,
            },] },
];
DlDateTimePickerComponent.ctorParameters = () => [
    { type: ElementRef, },
    { type: NgZone, },
    { type: DlDateAdapter, },
    { type: DlYearModelProvider, },
    { type: DlMonthModelProvider, },
    { type: DlDayModelProvider, },
    { type: DlHourModelProvider, },
    { type: DlMinuteModelProvider, },
];
DlDateTimePickerComponent.propDecorators = {
    "leftIconClass": [{ type: Input },],
    "maxView": [{ type: Input },],
    "minuteStep": [{ type: Input },],
    "minView": [{ type: Input },],
    "rightIconClass": [{ type: Input },],
    "startDate": [{ type: Input },],
    "startView": [{ type: Input },],
    "upIconClass": [{ type: Input },],
    "change": [{ type: Output },],
    "selectFilter": [{ type: Input },],
};
function hasValue(value) {
    return (typeof value !== 'undefined') && (value !== null);
}

const moment$8 = _moment;
const LONG_DATE_FORMAT = moment$8.localeData().longDateFormat('lll');
const INPUT_FORMATS = [
    'YYYY-MM-DDTHH:mm',
    'YYYY-MM-DDTHH:mm:ss',
    'YYYY-MM-DDTHH:mm:ss.SSS',
    'YYYY-MM-DD',
    LONG_DATE_FORMAT,
    moment$8.ISO_8601
];
class DlDateTimePickerModule {
}
DlDateTimePickerModule.decorators = [
    { type: NgModule, args: [{
                declarations: [DlDateTimePickerComponent],
                imports: [CommonModule],
                exports: [DlDateTimePickerComponent],
                providers: [
                    DlYearModelProvider,
                    DlMonthModelProvider,
                    DlDayModelProvider,
                    DlHourModelProvider,
                    DlMinuteModelProvider
                ],
            },] },
];
class DlDateTimePickerNumberModule {
}
DlDateTimePickerNumberModule.decorators = [
    { type: NgModule, args: [{
                imports: [DlDateTimePickerModule],
                exports: [DlDateTimePickerComponent],
                providers: [{ provide: DlDateAdapter, useClass: DlDateAdapterNumber }],
            },] },
];
class DlDateTimePickerDateModule {
}
DlDateTimePickerDateModule.decorators = [
    { type: NgModule, args: [{
                imports: [DlDateTimePickerModule],
                exports: [DlDateTimePickerComponent],
                providers: [{ provide: DlDateAdapter, useClass: DlDateAdapterNative }],
            },] },
];
class DlDateTimePickerMomentModule {
}
DlDateTimePickerMomentModule.decorators = [
    { type: NgModule, args: [{
                imports: [DlDateTimePickerModule],
                exports: [DlDateTimePickerComponent],
                providers: [{ provide: DlDateAdapter, useClass: DlDateAdapterMoment }],
            },] },
];
class DlDateTimePickerStringModule {
}
DlDateTimePickerStringModule.decorators = [
    { type: NgModule, args: [{
                imports: [DlDateTimePickerModule],
                exports: [DlDateTimePickerComponent],
                providers: [
                    { provide: DL_STRING_DATE_INPUT_FORMATS, useValue: INPUT_FORMATS },
                    { provide: DL_STRING_DATE_OUTPUT_FORMAT, useValue: LONG_DATE_FORMAT },
                    { provide: DlDateAdapter, useClass: DlDateAdapterString }
                ],
            },] },
];

export { DlDateAdapter, DlDateAdapterMoment, DlDateAdapterNative, DlDateAdapterNumber, DL_STRING_DATE_OUTPUT_FORMAT, DL_STRING_DATE_INPUT_FORMATS, DlDateAdapterString, DlDateTimePickerChange, DlDateTimePickerComponent, LONG_DATE_FORMAT, INPUT_FORMATS, DlDateTimePickerModule, DlDateTimePickerNumberModule, DlDateTimePickerDateModule, DlDateTimePickerMomentModule, DlDateTimePickerStringModule, DlDayModelProvider, DlHourModelProvider, DlMinuteModelProvider, DlMonthModelProvider, DlYearModelProvider };
//# sourceMappingURL=angular-bootstrap-datetimepicker.js.map
